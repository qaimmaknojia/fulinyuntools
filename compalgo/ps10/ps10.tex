\documentclass[12pt,letterpaper]{article}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{amsthm}

\newtheorem*{eg}{Example}

\author{Linyun Fu}
\title{CSCI 4020 Computer Algorithms Spring 2011\\
Problem Set 10}
\begin{document}
\maketitle
\section*{Chapter 10, Problem 2}
The difficulty in 3-SAT comes from the fact that there are $2^n$ possible
assignments to the input variables $x_l, x_2, \dots, x_n$, and there's no apparent
way to search this space in polynomial time. This intuitive picture, however,
might create the misleading impression that the fastest algorithms
for 3-SAT actually require time $2^n$. In fact, though it's somewhat counter-intuitive
when you first hear it, there are algorithms for 3-SAT that run
in significantly less than $2^n$ time in the worst case; in other words, they determine whether there's a satisfying assignment in less time than it
would take to enumerate all possible settings of the variables.

Here we'll develop one such algorithm, which solves instances of 3-SAT in $O(p(n)\cdot(\sqrt{3})^n)$ time for some polynomial $p(n)$. Note that the main
term in this running time is $(\sqrt{3})^n$, which is bounded by $1.74^n$.
\begin{itemize}
\item[(a)] For a truth assignment $\Phi$ for the variables $x_1, x_2, \dots, x_n$, we use $\Phi(x_i)$
to denote the value assigned by $\Phi$ to $x_i$. (This can be either 0 or
1.) If $\Phi$ and $\Phi'$ are each truth assignments, we define the distance
between $\Phi$ and $\Phi'$ to be the number of variables $x_i$ for which they
assign different values, and we denote this distance by $d(\Phi, \Phi')$. In
other words, $d(\Phi, \Phi') = \left|\left\{i : \Phi(x_i) \ne \Phi'(x_i)\right\}\right|$.

A basic building block for our algorithm will be the ability to
answer the following kind of question: Given a truth assignment $\Phi$
and a distance $d$, we'd like to know whether there exists a satisfying
assignment $\Phi'$ such that the distance from $\Phi$ to $\Phi'$ is at most $d$.
Consider the following algorithm, {\tt Explore}($\Phi, d$), that attempts to
answer this question.
%\vspace{-2ex}
\begin{table}[h!]
\texttt{
\begin{tabular}{l}
\hline
Explore($\Phi, d$)\\
\hspace{2em}If $\Phi$ is a satisfying assignment then return ``yes''\\
\hspace{2em}Else if $d = 0$ then return ``no''\\
\hspace{2em}Else\\
\hspace{4em}Let $C_i$ be a clause that is not satisfied by $\Phi$\\
\hspace{6em}(i.e., all three terms in $C_i$ evaluate to false)\\
\hspace{4em}Let $\Phi_1$ denote the assignment obtained from $\Phi$ by\\
\hspace{6em}taking the variable that occurs in the first term of\\
\hspace{6em}clause $C_i$ and inverting its assigned value\\
\hspace{4em}Define $\Phi_2$ and $\Phi_3$ analogously in terms of the\\
\hspace{6em}second and third terms of the clause $C_i$\\
\hspace{4em}Recursively invoke:\\
\hspace{6em}Explore($\Phi_1, d-1$)\\
\hspace{6em}Explore($\Phi_2, d-1$)\\
\hspace{6em}Explore($\Phi_3, d-1$)\\
\hspace{4em}If any of these three calls returns ``yes''\\
\hspace{6em}then return ``yes''\\
\hspace{4em}Else return ``no''\\
\hline
\end{tabular}
}
\end{table}

Prove that {\tt Explore}($\Phi, d$) returns ``yes'' if and only if there exists
a satisfying assignment $\Phi'$ such that the distance from $\Phi$ to $\Phi$ is at
most $d$. Also, give an analysis of the running time of {\tt Explore}($\Phi, d$)
as a function of $n$ and $d$.

\item[(b)] Clearly any two assignments $\Phi$ and $\Phi'$ have distance at most $n$
from each other, so one way to solve the given instance of 3-SAT
would be to pick an arbitrary starting assignment $\Phi$ and then run
{\tt Explore}($\Phi, n$). However, this will not give us the running time we
want.

Instead, we will need to make several calls to Explore, from
different starting points $\Phi$, and search each time out to more limited
distances. Describe how to do this in such a way that you can solve
the instance of 3-SAT in a running time of only $O(p(n)\cdot(\sqrt{3})^n)$.
\end{itemize}

\section*{Answer}

\section*{Chapter 11, Problem 10}
Suppose you are given an $n \times n$ {\em grid graph} $G$, as in Figure~1.

Associated with each node $v$ is a {\em weight} $w(v)$, which is a nonnegative
integer. You may assume that the weights of all nodes are distinct. Your goal is to choose an independent set $S$ of nodes of the grid, so that the
sum of the weights of the nodes in $S$ is as large as possible. (The sum of
the weights of the nodes in $S$ will be called its {\em total weight}.)

Consider the following greedy algorithm for this problem.
\begin{table}[h!]
\texttt{
\begin{tabular}{l}
\hline
The ``heaviest-first'' greedy algorithm:\\
\hspace{2em}Start with $S$ equal to the empty set\\
\hspace{2em}While some node remains in $G$\\
\hspace{4em}Pick a node $v_i$ of maximum weight\\
\hspace{4em}Add $v_i$ to $S$\\
\hspace{4em}Delete $v_i$ and its neighbors from $G$\\
\hspace{2em}Endwhile\\
\hspace{2em}Return $S$\\
\hline
\end{tabular}
}
\end{table}
\begin{itemize}
\item[(a)] Let $S$ be the independent set returned by the ``heaviest-first'' greedy
algorithm, and let $T$ be any other independent set in $G$. Show that, for
each node $v \in T$, either $v \in S$, or there is a node $v' \in? S$ so that $w(v) \le w(v')$
and $(v, v')$ is an edge of $G$.
\item[(b)] Show that the ``heaviest-first'' greedy algorithm returns an independent
set of total weight at least 1/4 times the maximum total weight of
any independent set in the grid graph $G$.
\end{itemize}

\section*{Answer}

\end{document}

