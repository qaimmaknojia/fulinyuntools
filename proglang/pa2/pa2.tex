\documentclass[12pt,letterpaper]{article}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\author{Linyun Fu}
\title{CSCI.4430/6969 Programming Languages Spring 2011\\
Programming Assignment \#2 -- Restricted Scheme Interpreter}
\begin{document}
\maketitle
\part*{Question}
The goal of this assignment is to write an interpreter in Oz for a restricted version of Scheme. The interpreter should be able to reduce Scheme expressions that corresponds to the lambda calculus in a call-by-value (applicative order) manner.

You are to use the following grammar for the lambda-calculus:
\begin{align}
\nonumber\left<\texttt{expression}\right> & ::= \left<\texttt{atom}\right>\\
\nonumber & ::= \texttt{lambda}(\left<\texttt{atom}\right> \left<\texttt{expression}\right>)\\
\nonumber & ::= [\left<\texttt{expression}\right> \left<\texttt{expression}\right>]
\end{align}
Your interpreter is expected to take the lambda calculus expression and perform repeatedly beta reduction until no longer possible (a value expression that can no longer be beta-reduced) and then eta reduction until no longer possible.

Once your interpreter is finished, you should be able to execute statements such as:

\tt
\{Browse \{Run [lambda(x x) y]\}\} \% should display y
\rm

\section*{10\% Extra Credit:}

Create a call-by-name (normal order evaluation) restricted Scheme interpreter.

\part*{Answer}
The interpreter is simply implemented as a top-down parser that takes an expression, recognizes its inner structure with the pattern matching mechanism of Oz, and parses the composing parts recursively. 

Below are some technical issues I summarized during the implementation of the interpreter.
\begin{itemize}
\item Alpha renaming is only necessary before each function application \texttt{[<exp1> <exp2>]}. When renaming bound variables in \texttt{<exp1>}, we need to avoid both the free variables in \texttt{<exp2>} and ALL variables in \texttt{<exp1>}. I rename variable X to X\#N, where N is chosen from natural numbers 1, 2, ...;
\item The difference between applicative order and normal order beta reduction is that the former reduce both \texttt{<exp1>} and \texttt{<exp2>} when \texttt{[<exp1> <exp2>]} is met, while the latter only reduce \texttt{<exp1>}.
\end{itemize}

\end{document}

