\documentclass[12pt,letterpaper]{article}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\author{Linyun Fu\and Yu Chen}
\title{CSCI.4430/6969 Programming Languages Spring 2011\\
Programming Assignment \#3 -- Sky Analyzer}
\begin{document}
\maketitle
\part*{Question}
The goal of this assignment is to practice concurrent and distributed programming using the SALSA programming language. 

You are to analyze three-dimensional data from the Sloan Digital Sky Survey, in particular, stars in our MilkyWay galaxy, for future human space colonization. Your program needs to compute the following: 
\begin{itemize}
\item \textbf{Closest neighbours} Compute the set of pairs of stars that minimize pairwise distance.
\item \textbf{Farthest neighbours} Compute the set of pairs of stars that maximize pairwise distance.
\item \textbf{Ideal hub stars} Compute the set of stars which minimize the maximal distance to any other star.
\item \textbf{Ideal jail stars} Compute the set of stars which maximize the minimal distance to any other star.
\item \textbf{Ideal capital stars} Compute the set of stars which minimize the average distance to all other stars. 
\end{itemize}

You are given a stars text file with the first line giving the total number of stars in the file followed by one line per star representing each star's three dimensions $\left<x,y,z\right>$ as X Y Z. Please remove duplicate entries in your program. Your output should look as follows:\\
\\
$d_1$  // minimal pairwise distance\\
$s_{11}$ $s_{12}$\\
$s_{13}$ $s_{14}$\\
...\\
\\
$d_2$  // maximal pairwise distance\\
$s_{21}$ $s_{22}$\\
$s_{23}$ $s_{24}$\\
...\\
\\
$d_3$ // minimum maximal distance\\
$s_{31}$ $s_{32}$\\
$s_{33}$ $s_{34}$\\
...\\
\\
$d_4$ // maximum minimal distance\\
$s_{41}$ $s_{42}$\\
$s_{43}$ $s_{44}$\\
... \\
\\
$d_5$ // minimal average distance\\
$s_{51}$\\
$s_{52}$\\
...\\

where $d_i$ denotes a distance and $s_{ij}$ denotes a three dimensional star coordinate. 

\section*{Part 1 -- Concurrent Solution}
Using SALSA, write an actor-based solution to the space colonization problem.

\section*{Part 2 -- Distributed Solution}
Write a distributed space colonization solution in SALSA.

\section*{Extra Credit -- Mobile Actors Solution}
Write an extension of your distributed space colonization solution so that actors can move to find better computational resources. 

\section*{Other Possible Extensions}
\begin{itemize}
\item Provide an analysis of sequential vs.~parallel execution performance.
\item Provide an analysis of scalability.
\item Develop a fault-tolerant distributed solution.
\end{itemize}

\part*{Answer}
\section*{Part 1 -- Concurrent Solution}
Our solution works in the following way (see the \texttt{cact} message handler of \texttt{Analyzer}). 
\begin{itemize}
\item The \texttt{Analyzer} actor sends each \texttt{Worker} actor the coordinates of $n$ stars, where $n$ can be designated by the user. 
\item Each worker calculates the pair-wise distances among stars that she knows (see the \texttt{calc} message handler of \texttt{Worker}).
\item Each worker asks the other workers for their coordinate data and calculate each distance between one of her stars and one of the stars not sent to her by the analyzer.
\item Each worker sends back her calculation results to the analyzer, which contains the closest neighbours, the farthest neighbours, the ideal hub stars, the deal jail stars, and the deal capital stars to the best of her knowledge. Then the analyzer aggregates them and print the final result (see the \texttt{summarize} message handler of \texttt{Analyzer}).
\end{itemize}

\section*{Part 2 -- Distributed Solution}
The distributed solution works in the same way as the concurrent solution, except that the workers migrate to different theaters at the beginning (see the \texttt{dact} message handler of \texttt{Analyzer}).

\section*{Extra Credit -- Mobile Actors Solution}
When a worker finishes her job, she will send a \texttt{loadBalance} message to the analyzer, who keeps counting the number of active workers at each theater and migrates workers to balance load among theaters.

\section*{Extensions}
\subsection*{Analysis of sequential vs.~parallel execution performance}
Since we experiment on one machine and use different port numbers to simulate theaters on different machines, we estimate the performance of parallel execution in the following way.
\begin{itemize}
\item We count the time spent on the analyzer sending data to each Worker actors, which is denoted as $t_{\textrm{send}}$;
\item We count the time spent on the theater that finishes the job last, which is denoted as $t_{\textrm{work}}$;
\item We count the time spent on the analyzer aggregating results from workers, which is denoted as $t_{\rm aggr}$;
\item Adding the above three items together, we get the estimated parallel execution time $t_{\rm para} = t_{\textrm{send}}+t_{\textrm{work}}+t_{\rm aggr}$.
\end{itemize}

Table~1 shows the computing times with different numbers of theaters on dataset \texttt{s840.txt}, which contains the first 840 stars coordinates from \texttt{stars_21_xyz.txt}. Sequential execution is when there is only one worker. Work load is spread evenly among theaters. All the experiments are performed on an Acer Aspire 5741Z-5433 laptop with an Intel P6000 processor (1.86GHz$\times$2, 3MB L3 cache) and 4GB DDR3 memory.

\begin{table}
\begin{center}
\caption{Computing time with different numbers of theaters}
\begin{tabular}{r|r}
\#theater & time(ms)\\
\hline
1 & \\
2 & \\
3 & \\
4 & \\
5 & \\
6 & \\
7 & \\
8 & \\
\end{tabular}
\end{center}
\end{table}

\subsection*{Analysis of scalability}
Since the number of stars assigned to each worker can be flexibly tuned, our solution is very scalable and can make good use of any feasible number of machines.

\subsection*{Fault-tolerant distributed solution}
This can be easily implemented by sending the coordinates of one star to multiple workers at different theaters, so that if some but not all of these actors fail, we can still get the computing result about this star. The number of copies can be designated by the user with the \texttt{ncopy} parameter.
\end{document}

