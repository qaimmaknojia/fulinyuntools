module sky;

import java.io.*;
import java.util.*;

/* Analyzer.salsa -- Parallel distance calculation rules
 *
 * Input: 
 *    1.  starsFile.txt, a stars text file with the first line giving the total number of stars in the file 
 *        followed by one line per star representing each star's three dimensions <x,y,z> as X Y Z. 
 *    2.  n, number of actors.
 *    3.  nameServer, the name server
 *    4.  theatersFile.txt, a file containing theater locations
 *
 * Output:  
 *    1.  Closest neighbours, the set of pairs of stars that minimize pairwise distance.
 *    2.  Farthest neighbours, the set of pairs of stars that maximize pairwise distance.
 *    3.  Ideal hub stars, the set of stars which minimize the maximal distance to any other star.
 *    4.  Ideal jail stars, the set of stars which maximize the minimal distance to any other star.
 *    5.  Ideal capital stars, the set of stars which minimize the average distance to all other stars.
 *
 * Algorithm:
 *    1.  
 *    2.  
 *    3a. 
 *    3b. 
 *
 * Note:  
 *
 */

behavior Analyze {
	String starsFile = "stars_21_xyz.txt";    // Stars file
	long initialTime;    // Starting Time
	String nameServer = "localhost";        // Name Server
	String theatersFile = "theatersFile.txt";    // File containing the theaters          
	String dedupFile = "dedup.txt";
	int nstar; // number of different stars

	int X = 0, Y = 1, Z = 2, MIN = 3, MAX = 4, XMIN = 5, YMIN = 6, ZMIN = 7, XMAX = 8, YMAX = 9, ZMAX = 10, AVG = 11, RESULTSIZE = 12; // used to encode the result of one worker with an array of doubles

	void act(String args[]) {
		int argc = args.length;
		if(argc>=1) starsFile=args[0];
		if(argc>=2) nameServer=args[1];
		if(argc>=3) theatersFile = args[2];
		dedup()@distributeWork()@endTimer();
	}      

	/* Deduplicate the stars file, return the name of the deduplicated file */
	void dedup() {
		Hashset lineset = new Hashset();
		try {
			BufferedReader in = new BufferedReader(new FileReader(starsFile));
			while ((star = in.readLine()) != null) {
				lineset.add(star);
			}
			in.close();
		} catch (IOException ioe) {
			standardOutput<-println("[error] Can't open the file " + starsFile + " for reading.");
		}

		try {
			PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(dedupFile)));
			for (Iterator i = lineset.iterator(); i.hasNext(); ) out.println((String)i.next());
			out.close();
		} catch (IOException ioe) {
			standardOutput<-println("[error] Can't write to file " + dedupFile);
		}

		nstar = lineset.size();
	}

	/* Distribute to the actors based on the deduplicated stars file */
	void distributeWork() {

		//create actors and assign data
		Worker[] workers = new Worker[nstar];
		for (int i = 0; i < nstar; i++) {                                   
			workers[i] = new Worker();
		}

		// read available theaters
		Vector theaters = new Vector();
		String theater;
		try {
			BufferedReader in = new BufferedReader(new FileReader(theatersFile));
			while ((theater = in.readLine()) != null) {
				theaters.add(theater);
			}
			in.close(); 
		} catch (IOException ioe) {
			standardOutput<-println("[error] Can't open the file " + theatersFile + " for reading.");
		}

		// migrate actors to theaters
		for (int i = 0; i < nstar; i++) {
			standardOutput<-println("Sending actor "+
					"uan://"+nameServer+":3030/a"+i+" to "+
					"rmsp://"+theaters.get(i%theaters.size())+"/a"+i);

			workers[i] = new Worker() at  
				(new UAN("uan://"+nameServer+":3030/a"+i), 
				 new UAL("rmsp://"+theaters.get(i%theaters.size())+"/a"+i)
				);
		}

		//start computation
		standardOutput<-println(">>>>>>Starting the computation");
		initialTime = System.currentTimeMillis();
		join {
			for (int i = 0; i < nstar; i++) {
				workers[i]<-calc(i, dedupFile, nstar);
			}
		}@summarize(token);
	}

	void endTimer(){
		long finalTime = System.currentTimeMillis();
		long runningTime = finalTime - initialTime;
		standardOutput<-println("Running time for star calculation is " + 
				runningTime+" ms.");
	}

	void summarize(double[][] results) {

		double cndis = Double.MAX_VALUE; // closest neighbour distance
		Array[] cn = new Array[6]; // closest neighbour pairs
		double fndis = 0.0; // farthest neighbour distance
		Array[] fn = new Array[6]; // farthest neighbour pairs
		double minmaxdis = Double.MAX_VALUE; // minimum max distance
		Array[] ihs = new Array[3]; // ideal hub stars
		double maxmindis = 0.0; // maximum min distance
		Array[] ijs = new Array[3]; // ideal jail stars
		double minavgdis = Double.MAX_VALUE; // minimum average distance
		Array[] ics = new Array[3]; // ideal capital stars

		for (int i = 0; i < results.length; i++){
			if (results[i][MIN] < cndis) {
				cndis = results[i][MIN];
				for (int i = 0; i < 6; i++) cn[i].clear();
				cn[0].add(results[i][X]);
				cn[1].add(results[i][Y]);
				cn[2].add(results[i][Z]);
				cn[3].add(results[i][XMIN]);
				cn[4].add(results[i][YMIN]);
				cn[5].add(results[i][ZMIN]);
			} else if (results[i][MIN] == cndis) {
				cn[0].add(results[i][X]);
				cn[1].add(results[i][Y]);
				cn[2].add(results[i][Z]);
				cn[3].add(results[i][XMIN]);
				cn[4].add(results[i][YMIN]);
				cn[5].add(results[i][ZMIN]);
			}


		}

		standardOutput<-println("With "+n+" workers, our calculation of the stars in "+starsFile+" gets the following results:\n"+result);
		return new Result(total); 
	}

}

