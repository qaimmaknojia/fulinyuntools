module sky;

import java.io.*;
import java.util.*;

/* Analyzer.salsa -- Parallel distance calculation rules
 *
 * Input: 
 *    1.  starsFile.txt, a stars text file with the first line giving the total number of stars in the file 
 *        followed by one line per star representing each star's three dimensions <x,y,z> as X Y Z. 
 *    2.  n, number of actors.
 *    3.  nameServer, the name server
 *    4.  theatersFile.txt, a file containing theater locations
 *
 * Output:  
 *    1.  Closest neighbours, the set of pairs of stars that minimize pairwise distance.
 *    2.  Farthest neighbours, the set of pairs of stars that maximize pairwise distance.
 *    3.  Ideal hub stars, the set of stars which minimize the maximal distance to any other star.
 *    4.  Ideal jail stars, the set of stars which maximize the minimal distance to any other star.
 *    5.  Ideal capital stars, the set of stars which minimize the average distance to all other stars.
 *
 * Algorithm:
 *    1.  
 *    2.  
 *    3a. 
 *    3b. 
 *
 * Note:  
 *
 */

behavior Analyzer {
	String starsFile = "test.txt";    // Stars file
	long initialTime;    // Starting Time
	String nameServer = "localhost";        // Name Server
	String theatersFile = "theatersFile.txt";    // File containing the theaters          
	String dedupFile = "dedup.txt";
	int nstar; // number of different stars
	int load = 3; // number of stars for each worker
	double[][] coords; // all star coordinates

	int X = 0, Y = 1, Z = 2, MIN = 3, MAX = 4, XMIN = 5, YMIN = 6, ZMIN = 7, XMAX = 8, YMAX = 9, ZMAX = 10, AVG = 11, START = 12, END = 13, RESULTSIZE = 14; // used to encode the result of one worker with an array of doubles

	void act(String args[]) {
		if (args.length >= 1) {
			String lastarg = args[args.length-1];
			if (lastarg.equalsIgnoreCase("--concurrent") || lastarg.equalsIgnoreCase("-c")) {
				String[] nargs = new String[args.length-1];
				for (int i = 0; i < nargs.length; i++) nargs[i] = args[i];
				cact(nargs);
			} else {
				dact(args);
			}
		} else {
			dact(args);
		}
	}      

	/** concurrent */
	void cact(String args[]) {
		int argc = args.length;
		if (argc >= 1) starsFile = args[0];
		if (argc >= 2) load = Integer.parseInt(args[1]);
		dedup()@distributeWorkC();
	}

	/** distributed */
	void dact(String args[]) {
		int argc = args.length;
		if (argc >= 1) starsFile = args[0];
		if (argc >= 2) nameServer = args[1];
		if (argc >= 3) theatersFile = args[2];
		if (args >= 4) load = Integer.parseInt(args[3]);
		dedup()@distributeWork();
	}

	/** Deduplicate the stars file, return the name of the deduplicated file */
	void dedup() {
		HashSet lineset = new HashSet();
		try {
			BufferedReader in = new BufferedReader(new FileReader(starsFile));
			String star;
			while ((star = in.readLine()) != null) if (!star.equalsIgnoreCase("")) lineset.add(star);
			in.close();
		} catch (IOException ioe) {
			standardOutput<-println("[error] Can't open the file " + starsFile + " for reading.");
		}

		try {
			PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(dedupFile)));
			for (Iterator i = lineset.iterator(); i.hasNext(); ) out.println((String)i.next());
			out.close();
		} catch (IOException ioe) {
			standardOutput<-println("[error] Can't write to file " + dedupFile);
		}

		nstar = lineset.size();
		coords = new double[nstar][3];
		try {
			BufferedReader in = new BufferedReader(new FileReader(dedupFile));
			int i = 0;
			for (String star = in.readLine(); star != null && !star.equalsIgnoreCase(""); star = in.readLine()) {
				String[] parts = star.split(" ");
				for (j = 0; j < 3; j++) coords[i][j] = Double.parseDouble(parts[j]);
				i++;
			}
			in.close();
		} catch (IOException ioe) {
			standardOutput<-println("[error] Can't open the file " + dedupFile + " for reading.");
		}

	}

	/** Distribute to the actors based on the deduplicated stars file for distributed computation */
	void distributeWork() {

		//create actors and assign data
		int nw = nstar/load;
		if (nstar%load != 0) nw++;
		Worker[] workers = new Worker[nw];
		for (int i = 0; i < nw; i++) {                                   
			workers[i] = new Worker();
		}

		// read available theaters
		Vector theaters = new Vector();
		String theater;
		try {
			BufferedReader in = new BufferedReader(new FileReader(theatersFile));
			while ((theater = in.readLine()) != null) {
				theaters.add(theater);
			}
			in.close(); 
		} catch (IOException ioe) {
			standardOutput<-println("[error] Can't open the file " + theatersFile + " for reading.");
		}

		// migrate actors to theaters
		for (int i = 0; i < nstar; i++) {
			standardOutput<-println("Sending actor "+
					"uan://"+nameServer+":3030/a"+i+" to "+
					"rmsp://"+theaters.get(i%theaters.size())+"/a"+i);

			workers[i] = new Worker() at  
				(new UAN("uan://"+nameServer+":3030/a"+i), 
				 new UAL("rmsp://"+theaters.get(i%theaters.size())+"/a"+i)
				);
		}

		//start computation
		standardOutput<-println(">>>>>>Starting the computation");
		initialTime = System.currentTimeMillis();
		for (int i = 0; i < nw; i++) {
			size = load;
			if (i == nw-1) {
				size = nstar-(nw-1)*load;
			}	
			double[][] data = new double[size][3];
			for (int j = i*load, jj = 0; j < i*load+load && j < nstar; j++, jj++) for (int k = 0; k < 3; k++) data[jj][k] = coords[j][k];
			workers[i]<-getData(data);
		}
		join {
			for (int i = 0; i < nstar; i++) {
				Worker w = new Worker();
				join {
				for (int j = 0; j < nw; j++) {
					w<-migrate(workers[j].getUAL())@
					w<-getDataFromColleague(workers[j])@w<-calc(coords[i][0], coords[i][1], coords[i][2]);
				}
				}@sumcolumn(token)
			}
		}@summarize(token);
	}

	Vector sumcolumn(Object[] snippets) {
		
		double min = Double.MAX_VALUE;
		double max = 0.0;
		double avg = 0.0;
		double xmin;
		double ymin;
		double zmin;
		double xmax;
		double ymax;
		double zmax;

		for (int i = 0; i < snippets.length; i++) {
			Vector v = (Vector)snippets[i];
			if (v.get(MIN) < min) {
				min = v.get(MIN);
				xmin = v.get(XMIN);
				ymin = v.get(YMIN);
				zmin = v.get(ZMIN);
			}
			if (v.get(MAX) > max) {
				max = v.get(MAX);
				xmax = v.get(XMAX);
				ymax = v.get(YMAX);
				zmax = v.get(ZMAX);
			}
			avg += v.get(AVG);
		}

		double[] ret = new double[RESULTSIZE];
		Vector v = (Vector)snippets[0];
		ret[X] = v.get(X);
		ret[Y] = v.get(Y);
		ret[Z] = v.get(Z);
		ret[MIN] = min;
		ret[MAX] = max;
		ret[AVG] = avg;
		ret[XMIN] = xmin;
		ret[YMIN] = ymin;
		ret[ZMIN] = zmin;
		ret[XMAX] = xmax;
		ret[YMAX] = ymax;
		ret[ZMAX] = zmax;
		convert2vector(ret)@currentContinuation;
	}

	Vector convert2vector(double[] a) {
		Vector r = new Vector();
		for (int i = 0; i < a.length; i++) r.add(a[i]);
		return r;
	}

	/** Distribute to the actors based on the deduplicated stars file for concurrent computation*/
	void distributeWorkC() {

		//create actors and assign data
		Worker[] workers = new Worker[nstar];
		for (int i = 0; i < nstar; i++) {                                   
			workers[i] = new Worker();
		}

		//start computation
		standardOutput<-println(">>>>>>Starting the computation");
		initialTime = System.currentTimeMillis();
		join {
			for (int i = 0; i < nstar; i++) {
				workers[i]<-calc(i, dedupFile, nstar);
			}
		}@summarize(token);
	}

	void endTimer(){
		long finalTime = System.currentTimeMillis();
		long runningTime = finalTime - initialTime;
		standardOutput<-println("Running time for star calculation is " + 
				runningTime+" ms.");
	}

	void summarize(Object[] results) {

		double cndis = Double.MAX_VALUE; // closest neighbour distance
		Vector[] cn = new Vector[6]; // closest neighbour pairs
		for (int i = 0; i < 6; i++) cn[i] = new Vector();
		double fndis = 0.0; // farthest neighbour distance
		Vector[] fn = new Vector[6]; // farthest neighbour pairs
		for (int i = 0; i < 6; i++) fn[i] = new Vector();
		double minmaxdis = Double.MAX_VALUE; // minimum max distance
		Vector[] ihs = new Vector[6]; // ideal hub stars
		for (int i = 0; i < 6; i++) ihs[i] = new Vector();
		double maxmindis = 0.0; // maximum min distance
		Vector[] ijs = new Vector[6]; // ideal jail stars
		for (int i = 0; i < 6; i++) ijs[i] = new Vector();
		double minavgdis = Double.MAX_VALUE; // minimum average distance
		Vector[] ics = new Vector[3]; // ideal capital stars
		for (int i = 0; i < 3; i++) ics[i] = new Vector();

		//standardOutput<-println("summing...");
		for (int i = 0; i < nstar; i++){
			Vector v = (Vector)results[i];
			double rmin = (Double)v.get(MIN);
			double rmax = (Double)v.get(MAX);
			double ravg = (Double)v.get(AVG);
			double rx = (Double)v.get(X);
			double ry = (Double)v.get(Y);
			double rz = (Double)v.get(Z);
			double rxmin = (Double)v.get(XMIN);
			double rymin = (Double)v.get(YMIN);
			double rzmin = (Double)v.get(ZMIN);
			double rxmax = (Double)v.get(XMAX);
			double rymax = (Double)v.get(YMAX);
			double rzmax = (Double)v.get(ZMAX);
			//standardOutput<-println(rmin+" "+rmax+" "+ravg+" "+rx+" "+ry+" "+rz);

			if (rmin < cndis) {
				cndis = rmin;
				for (int j = 0; j < 6; j++) cn[j].clear();
				cn[0].add(rx);
				cn[1].add(ry);
				cn[2].add(rz);
				cn[3].add(rxmin);
				cn[4].add(rymin);
				cn[5].add(rzmin);
			} else if (rmin == cndis) {
				cn[0].add(rx);
				cn[1].add(ry);
				cn[2].add(rz);
				cn[3].add(rxmin);
				cn[4].add(rymin);
				cn[5].add(rzmin);
			}

			if (rmax > fndis) {
				fndis = rmax;
				for (int j = 0; j < 6; j++) fn[j].clear();
				fn[0].add(rx);
				fn[1].add(ry);
				fn[2].add(rz);
				fn[3].add(rxmax);
				fn[4].add(rymax);
				fn[5].add(rzmax);
			} else if (rmax == fndis) {
				fn[0].add(rx);
				fn[1].add(ry);
				fn[2].add(rz);
				fn[3].add(rxmax);
				fn[4].add(rymax);
				fn[5].add(rzmax);
			}

			if (rmax < minmaxdis) {
				minmaxdis = rmax;
				for (int j = 0; j < 6; j++) ihs[j].clear();
				ihs[0].add(rx);
				ihs[1].add(ry);
				ihs[2].add(rz);
				ihs[3].add(rxmax);
				ihs[4].add(rymax);
				ihs[5].add(rzmax);
			} else if (rmax == minmaxdis) {
				ihs[0].add(rx);
				ihs[1].add(ry);
				ihs[2].add(rz);
				ihs[3].add(rxmax);
				ihs[4].add(rymax);
				ihs[5].add(rzmax);
			}

			if (rmin > maxmindis) {
				maxmindis = rmin;
				for (int j = 0; j < 6; j++) ijs[j].clear();
				ijs[0].add(rx);
				ijs[1].add(ry);
				ijs[2].add(rz);
				ijs[3].add(rxmin);
				ijs[4].add(rymin);
				ijs[5].add(rzmin);
			} else if (rmin == maxmindis) {
				ijs[0].add(rx);
				ijs[1].add(ry);
				ijs[2].add(rz);
				ijs[3].add(rxmin);
				ijs[4].add(rymin);
				ijs[5].add(rzmin);
			}

			if (ravg < minavgdis) {
				minavgdis = ravg;
				for (int j = 0; j < 3; j++) ics[j].clear();
				ics[0].add(rx);
				ics[1].add(ry);
				ics[2].add(rz);
			} else if (ravg == minavgdis) {
				ics[0].add(rx);
				ics[1].add(ry);
				ics[2].add(rz);
			}

		}

		token cndedup = dedupPair(cn);
		token fndedup = dedupPair(fn);

		standardOutput<-println("Stars file: "+starsFile+"\nnumber of stars: "+nstar+"\n\nminimal pairwise distance: "+cndis)@
			outputVector(cndedup)@
			standardOutput<-println(token)@
			standardOutput<-println("maximal pairwise distance: "+fndis)@
			outputVector(fndedup)@
			standardOutput<-println(token)@
			standardOutput<-println("minimum maximal distance: "+minmaxdis)@
			outputVector(ihs)@
			standardOutput<-println(token)@
			standardOutput<-println("maximum minimal distance: "+maxmindis)@
			outputVector(ijs)@
			standardOutput<-println(token)@
			standardOutput<-println("minimal average distance: "+minavgdis)@
			outputVector(ics)@
			standardOutput<-println(token)@
			endTimer();
	}

	Vector[] dedupPair(Vector[] pairs) {
		for (int i = 1; i < pairs[0].size(); ) {
			boolean removed = false;
			for (int j = 0; j < i; j++) {
				double i0 = (Double)pairs[0].get(i);
				double i1 = (Double)pairs[1].get(i);
				double i2 = (Double)pairs[2].get(i);
				double i3 = (Double)pairs[3].get(i);
				double i4 = (Double)pairs[4].get(i);
				double i5 = (Double)pairs[5].get(i);
				double j0 = (Double)pairs[0].get(j);
				double j1 = (Double)pairs[1].get(j);
				double j2 = (Double)pairs[2].get(j);
				double j3 = (Double)pairs[3].get(j);
				double j4 = (Double)pairs[4].get(j);
				double j5 = (Double)pairs[5].get(j);
				if (i0 == j3 && i1 == j4 && i2 == j5 && i3 == j0 && i4 == j1 && i5 == j2) {
					for (int k = 0; k < 6; k++) pairs[k].remove(i);
					removed = true;
					break;
				}
			}
			if (!removed) i++;
		}
		return pairs;
	}

	String outputVector(Vector[] list) {
		join {
			for (int i = 0; i < list[0].size(); i++) outputColumn(list, i);
		}@concat(token)@currentContinuation;
	}

	String concat(Object[] strings) {
		String ret = "";
		for (int i = 0; i < strings.length; i++) ret += (String)strings[i]+"\n";
		return ret;
	}

	String outputColumn(Vector[] list, int col) {
		String ret = "<";
		for (int i = 0; i < list.length; i++) {
			ret += list[i].get(col);
			if (i == list.length-1) ret += ">";
			else if (i%3 == 2) ret += "> <";
			else ret += ",";
		}
		return ret;
	}
}

