module sky;

import java.io.*;
import java.util.*;

/* Analyzer.salsa -- parallel space colonization calculation
 *
 * Input: 
 *    1.  starsFile.txt, a stars text file with the first line giving the total number of stars in the file 
 *        followed by one line per star representing each star's three dimensions <x,y,z> as X Y Z.
 *    2.  load, number of stars assigned to each worker.
 *    3.  ncopy, the number of copies of each star coordinate to spread out in the whole system, for fault-tolerant computation.
 *    4.  nameServer, the name server.
 *    5.  theatersFile.txt, a file containing theater locations.
 *    6.  -c or --concurrent, indication of concurrent calculation instead of the default distributed calculation.
 *
 * Output:  
 *    1.  closest neighbours, the set of pairs of stars that minimize pairwise distance.
 *    2.  farthest neighbours, the set of pairs of stars that maximize pairwise distance.
 *    3.  ideal hub stars, the set of stars which minimize the maximal distance to any other star, along with the stars farthest away from each hub.
 *    4.  ideal jail stars, the set of stars which maximize the minimal distance to any other star, along with the stars closest to each jail.
 *    5.  ideal capital stars, the set of stars which minimize the average distance to all other stars.
 *
 * Algorithm:
 *    1.  remove duplicate star coordinates;
 *    2.  make ncopy copies of the coordinates and distribute them to workers, each of which gets load star coordinates;
 *    3.  each worker calculates the closest neighbors, farthest neighbors, ideal hubs, ideal jails and ideal capitals within the set of stars assigned to her;
 *    3a. each worker asks her colleagues for different parts of data needed for her job;
 *    3b. workers on a crowded theater may migrate to a less crowded one during their calculation;
 *    4.  the analyzer summarizes the results sent back from all the workers.
 *
 * Note:  the default execution is taking test.txt as the stars file, load = 3, ncopy = 1, nameServer = localhost, and theatersFile.txt as theater information, in a distributed manner.
 *
 */

behavior Analyzer {
	String starsFile = "test.txt";    // Stars file
	long initialTime;    // Starting Time
	long tsend; // time spent on sending data to workers
	long twork; // time spent on the slowest theater
	long taggr; // time spent on the aggregation
	String nameServer = "localhost";        // Name Server
	String theatersFile = "theatersFile.txt";    // File containing the theaters          
	String dedupFile = "dedup.txt";
	int nstar; // number of different stars
	int load = 3; // number of stars for each worker
	int ncopy = 1; // number of copies of the star file to send out to the workers
	double[][] coords; // all star coordinates
	boolean[] active; // record each worker is currently active or not
	int[] nworker; // number of active workers at each theater
	Worker[] workers; // the references to the workers
	Vector theaters; // theater names

	void act(String args[]) {
		if (args.length >= 1) {
			String lastarg = args[args.length-1];
			if (lastarg.equalsIgnoreCase("--concurrent") || lastarg.equalsIgnoreCase("-c")) {
				String[] nargs = new String[args.length-1];
				for (int i = 0; i < nargs.length; i++) nargs[i] = args[i];
				cact(nargs);
			} else {
				dact(args);
			}
		} else {
			dact(args);
		}
	}      

	/** concurrent */
	void cact(String args[]) {
		int argc = args.length;
		if (argc >= 1) starsFile = args[0];
		if (argc >= 2) load = Integer.parseInt(args[1]);
		initialTime = System.currentTimeMillis();
		dedup()@distributeWorkC();
	}

	/** distributed */
	void dact(String args[]) {
		int argc = args.length;
		if (argc >= 1) starsFile = args[0];
		if (argc >= 2) load = Integer.parseInt(args[1]);
		if (argc >= 3) ncopy = Integer.parseInt(args[2]);
		if (argc >= 4) nameServer = args[3];
		if (argc >= 5) theatersFile = args[4];
		initialTime = System.currentTimeMillis();
		dedup()@distributeWork();
	}

	/** Deduplicate the stars file, return the name of the deduplicated file */
	void dedup() {
		HashSet lineset = new HashSet();
		try {
			BufferedReader in = new BufferedReader(new FileReader(starsFile));
			in.readLine();
			String star;
			while ((star = in.readLine()) != null) if (!star.equalsIgnoreCase("")) lineset.add(star);
			in.close();
		} catch (IOException ioe) {
			standardOutput<-println("[error] Can't open the file " + starsFile + " for reading.");
		}

		try {
			PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(dedupFile)));
			for (Iterator i = lineset.iterator(); i.hasNext(); ) out.println((String)i.next());
			out.close();
		} catch (IOException ioe) {
			standardOutput<-println("[error] Can't write to file " + dedupFile);
		}

		nstar = lineset.size();
		coords = new double[nstar][3];
		try {
			BufferedReader in = new BufferedReader(new FileReader(dedupFile));
			int i = 0;
			for (String star = in.readLine(); star != null && !star.equalsIgnoreCase(""); star = in.readLine()) {
				String[] parts = star.split(" ");
				for (int j = 0; j < 3; j++) coords[i][j] = Double.parseDouble(parts[j]);
				i++;
			}
			in.close();
		} catch (IOException ioe) {
			standardOutput<-println("[error] Can't open the file " + dedupFile + " for reading.");
		}

	}

	/** Distribute to the actors based on the deduplicated stars file for distributed computation */
	void distributeWork() {

		//create actors 
		int nw = nstar*ncopy/load;
		if (nstar*ncopy%load != 0) nw++;
		workers = new Worker[nw];
		for (int i = 0; i < nw; i++) workers[i] = new Worker();
		active = new boolean[nw];
		for (int i = 0; i < nw; i++) active[i] = true;

		// read available theaters
		theaters = new Vector();
		String theater;
		try {
			BufferedReader in = new BufferedReader(new FileReader(theatersFile));
			while ((theater = in.readLine()) != null) {
				theaters.add(theater);
			}
			in.close(); 
		} catch (IOException ioe) {
			standardOutput<-println("[error] Can't open the file " + theatersFile + " for reading.");
		}

		nworker = new int[theaters.size()];
		for (int i = 0; i < nworker.length; i++) nworker[i] = 0;

		// migrate actors to theaters
		String[] wnames = new String[nw];
		for (int i = 0; i < nw; i++) {
			standardOutput<-println("Sending actor "+
					"uan://"+nameServer+":3030/a"+i+" to "+
					"rmsp://"+theaters.get(i%theaters.size())+"/a"+i);

			workers[i] = new Worker() at  
				(new UAN("uan://"+nameServer+":3030/a"+i), 
				 new UAL("rmsp://"+theaters.get(i%theaters.size())+"/a"+i)
				);
			nworker[i%theaters.size()]+=1; // keep the numbers of workers at each theater
			wnames[i] = workers[i].getUAN().toString();
		}

		//start computation
		standardOutput<-println(">>>>>>Starting the computation");
		join {
			for (int i = 0; i < nw; i++) {
				int size = load;
				if (i == nw-1) {
					size = nstar*ncopy-(nw-1)*load;
				}	
				double[][] data = new double[size][3];
				for (int j = i*load, jj = 0; j < i*load+load && j < nstar; j++, jj++) for (int k = 0; k < 3; k++) data[jj][k] = coords[j%nstar][k];
				workers[i]<-getData(data, i, getUAN().toString());
			}
		}@getTsend()@join {
			for (int i = 0; i < nw; i++) {
				workers[i]<-calc(wnames);
			}
		}@summarize(token);

	}

	/** Distribute to the actors based on the deduplicated stars file for concurrent computation*/
	void distributeWorkC() {
		//create actors and assign data
		int nw = nstar*ncopy/load;
		if (nstar*ncopy%load != 0) nw++;
		workers = new Worker[nw];
		String[] wnames = new String[nw];
		for (int i = 0; i < nw; i++) {
			workers[i] = new Worker() at (new UAN("uan://localhost:3030/a"+i));
			wnames[i] = workers[i].getUAN().toString();
		}

		//start computation
		standardOutput<-println(">>>>>>Starting the computation");
		double data[][][] = new double[nw][][];
		for (int i = 0; i < nw; i++) {
			int size = load;
			if (i == nw-1) size = nstar*ncopy-(nw-1)*load;
			data[i] = new double[size][3];	
			for (int j = i*load, jj = 0; j < i*load+load && j < nstar; j++, jj++) for (int k = 0; k < 3; k++) data[i][jj][k] = coords[j%nstar][k];
		}
		join {
			for (int i = 0; i < nw; i++) {
				workers[i]<-getData(data[i], i, getUAN().toString());
			}
		}@getTsend()@join {
			for (int i = 0; i < nw; i++) {
				workers[i]<-calc(wnames);
			}
		}@summarize(token);

	}

	void getTsend() {
		tsend = System.currentTimeMillis()-initialTime;
	}

	void summarize(Object[] results) {
		//if (results == null) standardOutput<-println("\n!!!results==null!!!\n");
		long startTime = System.currentTimeMillis();
		//standardOutput<-println("\n!!!\n"+startTime+"\n!!!\n");
		Result[] rs = new Result[results.length];
		//standardOutput<-println("!!!start loop!!!");
		for (int i = 0; i < results.length; i++) {
			rs[i] = (Result)results[i];
			//standardOutput<-println("!!!"+i+"!!!");
		}
		int sumsize;
		if (theaters == null) sumsize = results.length;
		else sumsize = theaters.size();
		Result r = ResultAggregator.summarize(rs, sumsize);
		
		standardOutput<-println("Stars file: "+starsFile+"\nnumber of stars: "+nstar+"\n")@
			standardOutput<-println(r.toString(nstar))@
			getTaggr(startTime)@
			standardOutput<-println("estimated total time: "+(tsend+r.time+taggr)+" ms");
	}

	void getTaggr(long start) {
		long finalTime = System.currentTimeMillis();
		taggr = finalTime - start;
	}

	void loadBalance(int w) {
		active[w] = false;
		nworker[w%theaters.size()]-=1;
		for (int i = 0; i < theaters.size(); i++) for (int j = 0; j < theaters.size(); j++) if (nworker[i] > nworker[j]+1) {
			for (int k = i; k < active.length && nworker[i] > nworker[j]+1; k += theaters.size()) if (active[k]) {
				workers[k]<-migrate("rmsp://"+theaters.get(j%theaters.size())+"/a"+i);
				nworker[i]-=1;
				nworker[j]+=1;
			}
		}
	}

}

/*
 * 	Vector sumcolumn(Object[] snippets) {

 double min = Double.MAX_VALUE;
 double max = 0.0;
 double avg = 0.0;
 double xmin;
 double ymin;
 double zmin;
 double xmax;
 double ymax;
 double zmax;

 for (int i = 0; i < snippets.length; i++) {
 Vector v = (Vector)snippets[i];
 if (v.get(MIN) < min) {
 min = v.get(MIN);
 xmin = v.get(XMIN);
 ymin = v.get(YMIN);
 zmin = v.get(ZMIN);
 }
 if (v.get(MAX) > max) {
 max = v.get(MAX);
 xmax = v.get(XMAX);
 ymax = v.get(YMAX);
 zmax = v.get(ZMAX);
 }
 avg += v.get(AVG);
 }

 double[] ret = new double[RESULTSIZE];
 Vector v = (Vector)snippets[0];
 ret[X] = v.get(X);
 ret[Y] = v.get(Y);
 ret[Z] = v.get(Z);
 ret[MIN] = min;
 ret[MAX] = max;
 ret[AVG] = avg;
 ret[XMIN] = xmin;
 ret[YMIN] = ymin;
 ret[ZMIN] = zmin;
 ret[XMAX] = xmax;
 ret[YMAX] = ymax;
 ret[ZMAX] = zmax;
 convert2vector(ret)@currentContinuation;
 }

 Vector convert2vector(double[] a) {
 Vector r = new Vector();
 for (int i = 0; i < a.length; i++) r.add(a[i]);
 return r;
 }

*/

	/*
	Vector[] dedupPair(Vector[] pairs) {
		for (int i = 1; i < pairs[0].size(); ) {
			boolean removed = false;
			for (int j = 0; j < i; j++) {
				double i0 = (Double)pairs[0].get(i);
				double i1 = (Double)pairs[1].get(i);
				double i2 = (Double)pairs[2].get(i);
				double i3 = (Double)pairs[3].get(i);
				double i4 = (Double)pairs[4].get(i);
				double i5 = (Double)pairs[5].get(i);
				double j0 = (Double)pairs[0].get(j);
				double j1 = (Double)pairs[1].get(j);
				double j2 = (Double)pairs[2].get(j);
				double j3 = (Double)pairs[3].get(j);
				double j4 = (Double)pairs[4].get(j);
				double j5 = (Double)pairs[5].get(j);
				if (i0 == j3 && i1 == j4 && i2 == j5 && i3 == j0 && i4 == j1 && i5 == j2) {
					for (int k = 0; k < 6; k++) pairs[k].remove(i);
					removed = true;
					break;
				}
			}
			if (!removed) i++;
		}
		return pairs;
	}
	*/

	/*
	String outputVector(Vector[] list) {
		join {
			for (int i = 0; i < list[0].size(); i++) outputColumn(list, i);
		}@concat(token)@currentContinuation;
	}
	*/

	/*
	String concat(Object[] strings) {
		String ret = "";
		for (int i = 0; i < strings.length; i++) ret += (String)strings[i]+"\n";
		return ret;
	}
	*/

	/*
	String outputColumn(Vector[] list, int col) {
		String ret = "<";
		for (int i = 0; i < list.length; i++) {
			ret += list[i].get(col);
			if (i == list.length-1) ret += ">";
			else if (i%3 == 2) ret += "> <";
			else ret += ",";
		}
		return ret;
	}
	*/


