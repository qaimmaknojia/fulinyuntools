module sky;
import java.io.*;
import java.util.*;
import sky.util.*;

/* Worker.salsa -- 
 *   Worker for Parallel star calculation
 */

behavior Worker {

	double x = 0.0;
	double y = 0.0;
	double z = 0.0;
	double[][] stardata;
	//int start;
	//int end;

	int X = 0, Y = 1, Z = 2, MIN = 3, MAX = 4, XMIN = 5, YMIN = 6, ZMIN = 7, XMAX = 8, YMAX = 9, ZMAX = 10, AVG = 11, /*START = 12, END = 13, */RESULTSIZE = 12; // used to encode the result of one worker with an array of doubles

	void getData(double[][] data/*, int start, int end*/) {
		stardata = new double[data.length][3];
		for (int i = 0; i < data.length; i++) for (int j = 0; j < 3; j++) stardata[i][j] = data[i][j];
		//this.start = start;
		//this.end = end;
	}

	double[][] sendData() {
		return stardata;
	}

	void getDataFromColleague(Worker w) {
		w<-sendData()@getData(token);
	}

	/** calculate the distances from this star (n-th line, counting from 0) to all the other stars, there are totally nstar lines */
	Vector calc(double x, double y, double z) {
		
		this.x = x;
		this.y = y;
		this.z = z;
		getMinMax(stardata/*, start, end*/)@currentContinuation;
	}

	/** get the minimum distance and the maximum distance and the average distance from the n-th star to all the other stars */
	Vector getMinMax(double[][] values/*, int start, int end*/) {
		double[] r = new double[RESULTSIZE];
		//r[START] = new Integer(start);
		//r[END] = new Integer(end);
		r[X] = r[XMIN] = r[XMAX] = x;
		r[Y] = r[YMIN] = r[YMAX] = y;
		r[Z] = r[ZMIN] = r[ZMAX] = z;
		r[MIN] = Double.MAX_VALUE;
		r[MAX] = 0.0;
		r[AVG] = 0.0;
		reset(r, values)@convert2vector(token)@currentContinuation;
	}

	Vector convert2vector(double[] a) {
		Vector r = new Vector();
		for (int i = 0; i < a.length; i++) r.add(a[i]);
		return r;
	}

	/** get the Result object containing the minimum and the maximum distances */
	double[] reset(double[] r, double[][] values) {

		token rr = reset1(r, values[0]);

		for (int i = 1; i < values.length; i++) {
			rr = reset1(rr, values[i]);
		}

		iden(rr)@currentContinuation;

	}

	/** identity function */
	double[] iden(double[] r) {
		return r;
	}

	/** change the records for minimum and maximum distances for a Result object */
	double[] reset1(double[] r, double[] star) {

		double dx = x-star[0];
		double dy = y-star[1];
		double dz = z-star[2];
		if (dx != 0.0 || dy != 0.0 || dz != 0.0) {
			double dis = Math.sqrt(dx*dx+dy*dy+dz*dz);

			if (dis < r[MIN]) {
				r[MIN] = dis;
				r[XMIN] = star[0];
				r[YMIN] = star[1];
				r[ZMIN] = star[2];
			}

			if (dis > r[MAX]) {
				r[MAX] = dis;
				r[XMAX] = star[0];
				r[YMAX] = star[1];
				r[ZMAX] = star[2];
			}

			r[AVG] += dis;
		}
		return r;

	}

	/** for unit test */
	void act(String args[]) {
		double[][] stardata = {{0.0, 0.0, 0.0},{0.0, 1.0, 0.0},{0.0, 1.0, 5.0},{0.0, 0.0, 5.0}};
		double[][] stardata1 = {{0.0, 0.0, 0.0},{0.0, 1.0, 0.0}};
		double[][] stardata2 = {{0.0, 1.0, 0.0},{0.0, 1.0, 5.0},{0.0, 0.0, 5.0}};
		getData(stardata1)@calc(0.0, 0.0, 0.0)@displayResult(token)@
			getData(stardata2)@calc(0.0, 1.0, 0.0)@displayResult(token);
	}

	/** display the content of a Result object */
	Vector displayResult(Vector r) {
		double rmin = (Double)r.get(MIN);
		double rmax = (Double)r.get(MAX);
		double ravg = (Double)r.get(AVG);
		double rx = (Double)r.get(X);
		double ry = (Double)r.get(Y);
		double rz = (Double)r.get(Z);
		double rxmin = (Double)r.get(XMIN);
		double rymin = (Double)r.get(YMIN);
		double rzmin = (Double)r.get(ZMIN);
		double rxmax = (Double)r.get(XMAX);
		double rymax = (Double)r.get(YMAX);
		double rzmax = (Double)r.get(ZMAX);
		//int start = (Integer)r.get(START);
		//int end = (Integer)r.get(END);
		standardOutput<-println("\nThe final result for "+rx+" "+ry+" "+rz+" is\nmin distance: "+rmin+"\nfrom "+rxmin+" "+rymin+" "+rzmin+"\nmax distance: "+rmax+"\nfrom "+rxmax+" "+rymax+" "+rzmax+"\ntotal distance: "+ravg);

		return r;
	}

}

